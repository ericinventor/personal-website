---
title: Rubik's Cube Solver
subtitle: Website Design
layout: default
modal-id: 7
date: 2014-07-14
img: rubiks-cube-solver.jpg
thumbnail: rubiks-cube-solver.jpg
alt: image-alt
img-1: rubikscubesolver-gif.gif
project-date: 2019
age: 22
category: Robotics
description: While at Cornell, my Design with Embedded OS class involved a final project of our choosing as long as it involved a Raspberry Pi. My partner Ron and I decided to build a Robotic Rubik's Cube Solver. <br><br>I knew this had been done before, so I started by researching existing designs. Fundamentally, you really only need two degrees of freedom to solve a Rubik's cube--one to rotate the entire cube, and one to rotate a face. As long as the two are cleverly designed (like using gravity to engage a just-rotated cube to the actuator that spins the face), just two actuators can be used to manipulate every face of the cube. The downsides to this are that because there is only one actuator to spin the face, every move first involves orienting the cube correctly, then spining it the clockwise or counterclockwise. This adds lots of steps and makes the total time to solve the cube longer. The other aspect to this operation is grabbing and letting go of the cube's faces. Most designs involve some time of gripper that can engage and disengage with a section of the cube between each successive move. On the other extreme, since a cube has 6 sides, if there were 6 degrees of freedom, you would never need re-orient the cube, resulting in much faster solver times. 6-sided solver designs cannot have grippers that wrap around the edges of the cube, otherwise they would collide with the other faces when rotating.  6-sided solver designs often involve a keyed shaft that mates directly with the modified cube face, so there is no need to grab around the entire section of the cube, rotate it, and let it go, like we do when solving the cube with our hands. While not having to disengage or engage with the cube between moves makes for a faster solve, it normally involves a customized cube to mate with the machine, as opposed to using any Rubik's cube, and it can be more complicated to get the cube in and out of the solver. <br><br>My design goals were to create a solver that could solve any unmodified 3x3 Rubik's Cube in less than 2 minutes. I choose to reduce re-oreintation moves by having 4 actuators--for the front, back, left and right sides. The reason I didn't choose 5 is because it was more convenient to mount the camera beneath the cube, and have the cube placed into the machine from the top. The build consisted of a frame that I designed and laser-cut out of white acrylic. The Raspberry Pi was equipped with a camera to take an image of each side of the Rubik's Cube at the beginning of the solve. The captured configuration of the cube was stored in a matrix and passed to an existing cube solving algorithm. The solving algorithm would return the series of moves necessary to fully solve the cube. The mechanical arms would then execute the prescribed sequence in order to solve the cube. <br><br> The most challenging part about this build was not the software, but actually the mechanical hardware. Each arm had two degrees of freedom, one for rotation, and one for translation to engage or disengage with its respective cube side. Each claw was being rotated by a stepper motor, becuase they are precise, repeatable, and relatively quick. Because stepper motors are somewhat large and heavy, I did not want to have to translate each stepper motor with the claw. Instead I choose to have a linkage between with the stepper shaft and the claw that allowed for rotation and translation. I chose an electromagnetic solenoid as the actuator for the translation because it was simple, compact, quick to actuate, and easy to drive. My first attempt at achieveing translation and rotation without translating the steppers motor involved a sliding set of spur gears. The stepper motor drove a wide faced spur gear, and the claw was rigidly connected to an axle with a smaller spur gear that could slide back and forth along the larger spur gear beneath it as the solenoid was actuated. The problem with this approach was the backlash. With each consecutive 90-turn (in opposing directions) the error would accumulate due to the backlash in the spur gears. Because my system was not closed loop, meaning I did not actually know the true position of the claw, only the stepper motor's commanded shaft position, I could not correct this error easily and after enough turns the cube face would not be flush with the rest of the cube, preventing any other side from turning. My second attempt at this mechanical problem involved a custom designed coupler that would allow me to get rid of all gears, and hopefully all the backlash too. This coupler consisted of a hexagon that could slide in an out of a larger hexagon, but it was tightly-toleranced so if one hexagon rotated, the other would rotate in perfect sync. I 3D printed these hexagons, and then sanded them down to achieve a smooth finish that would slide with very little slop. This was not easy to do given imperfections in the 3D printing and my sanding. After many attempts, there was still a small amount of backlash that would cause issues after so many turns were executed.  This way I could achieve higher tolerances and hopefully eliminate the backlash. I should mention if I had installed an optical encoder on the shaft that was directly mounted to the claw, I could implement closed loop-control and achieve perfect 90-deg turns event if my linkage had backlash or slop. I wanted to keep is simple, not having to buy more expensive sensors, integrate more hardware, and write more software, so I choose to go for mechanical perfection... After a while, I built my Desktop CNC, which enabled me to CNC these couplers out of nylon instead of 3D printing. This got me closer to 0 backlash, but now I was having issued with inner hexagons not sliding very well. The tradeoff was between easy sliding and little backlash. In the end this system worked, but it was not 100% reliable. Please see our project website for the class.<br><br><a href="https://courses.ece.cornell.edu/ece5990/ECE5725_Fall2018_Projects/eb645_yh326_final/index.html#">Rubik's Cube Solver Project Website</a> 

---
